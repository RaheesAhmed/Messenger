import { BaseCallbackConfig, CallbackManager } from "../callbacks/manager.js";
import { Serializable } from "../load/serializable.js";
import { IterableReadableStream } from "../util/stream.js";
export type RunnableConfig = BaseCallbackConfig;
export type RunnableFunc<RunInput, RunOutput> = (input: RunInput) => RunOutput | Promise<RunOutput>;
export type RunnableLike<RunInput = any, RunOutput = any> = Runnable<RunInput, RunOutput> | RunnableFunc<RunInput, RunOutput> | {
    [key: string]: RunnableLike<RunInput, RunOutput>;
};
export declare abstract class Runnable<RunInput = any, RunOutput = any, CallOptions extends RunnableConfig = RunnableConfig> extends Serializable {
    protected lc_runnable: boolean;
    abstract invoke(input: RunInput, options?: Partial<CallOptions>): Promise<RunOutput>;
    bind(kwargs: Partial<CallOptions>): RunnableBinding<RunInput, RunOutput, CallOptions>;
    protected _getOptionsList(options: Partial<CallOptions> | Partial<CallOptions>[], length?: number): Partial<CallOptions>[];
    batch(inputs: RunInput[], options?: Partial<CallOptions> | Partial<CallOptions>[], batchOptions?: {
        maxConcurrency?: number;
    }): Promise<RunOutput[]>;
    _streamIterator(input: RunInput, options?: Partial<CallOptions>): AsyncGenerator<RunOutput>;
    stream(input: RunInput, options?: Partial<CallOptions>): Promise<IterableReadableStream<RunOutput>>;
    protected _separateRunnableConfigFromCallOptions(options?: Partial<CallOptions>): [RunnableConfig, Omit<Partial<CallOptions>, keyof RunnableConfig>];
    protected _callWithConfig<T extends RunInput>(func: (input: T) => Promise<RunOutput>, input: T, options?: RunnableConfig & {
        runType?: string;
    }): Promise<RunOutput>;
    protected _streamWithConfig<T extends RunOutput>(generator: AsyncGenerator<T>, options?: RunnableConfig & {
        runType?: string;
    }): AsyncGenerator<Awaited<T>, void, unknown>;
    _patchConfig(config?: Partial<CallOptions>, callbackManager?: CallbackManager | undefined): Partial<CallOptions>;
    pipe<NewRunOutput>(coerceable: RunnableLike<RunOutput, NewRunOutput>): RunnableSequence<RunInput, NewRunOutput>;
    transform?(generator: AsyncGenerator<RunInput>, options: Partial<CallOptions>): AsyncGenerator<RunOutput>;
    static isRunnable(thing: any): thing is Runnable;
}
export declare class RunnableSequence<RunInput = any, RunOutput = any> extends Runnable<RunInput, RunOutput> {
    protected first: Runnable<RunInput>;
    protected middle: Runnable[];
    protected last: Runnable<any, RunOutput>;
    lc_serializable: boolean;
    lc_namespace: string[];
    constructor(fields: {
        first: Runnable<RunInput>;
        middle?: Runnable[];
        last: Runnable<any, RunOutput>;
    });
    get steps(): Runnable<RunInput, any, BaseCallbackConfig>[];
    invoke(input: RunInput, options?: RunnableConfig): Promise<RunOutput>;
    batch(inputs: RunInput[], options?: RunnableConfig | RunnableConfig[], batchOptions?: {
        maxConcurrency?: number;
    }): Promise<RunOutput[]>;
    _streamIterator(input: RunInput, options?: RunnableConfig): AsyncGenerator<RunOutput>;
    pipe<NewRunOutput>(coerceable: RunnableLike<RunOutput, NewRunOutput>): RunnableSequence<RunInput, NewRunOutput>;
    static isRunnableSequence(thing: any): thing is RunnableSequence;
    static from<RunInput, RunOutput>([first, ...runnables]: [
        RunnableLike<RunInput>,
        ...RunnableLike[],
        RunnableLike<any, RunOutput>
    ]): RunnableSequence<RunInput, RunOutput>;
}
export declare class RunnableMap<RunInput> extends Runnable<RunInput, Record<string, any>> {
    lc_namespace: string[];
    lc_serializable: boolean;
    protected steps: Record<string, Runnable<RunInput>>;
    constructor(fields: {
        steps: Record<string, RunnableLike<RunInput>>;
    });
    invoke(input: RunInput, options?: Partial<BaseCallbackConfig>): Promise<Record<string, any>>;
}
export declare class RunnableLambda<RunInput, RunOutput> extends Runnable<RunInput, RunOutput> {
    lc_namespace: string[];
    protected func: RunnableFunc<RunInput, RunOutput>;
    constructor(fields: {
        func: RunnableFunc<RunInput, RunOutput>;
    });
    invoke(input: RunInput, options?: Partial<BaseCallbackConfig>): Promise<RunOutput>;
}
export declare class RunnablePassthrough<RunInput> extends Runnable<RunInput, RunInput> {
    lc_namespace: string[];
    lc_serializable: boolean;
    invoke(input: RunInput, options?: Partial<BaseCallbackConfig>): Promise<RunInput>;
}
export declare class RunnableBinding<RunInput, RunOutput, CallOptions extends BaseCallbackConfig> extends Runnable<RunInput, RunOutput, CallOptions> {
    lc_namespace: string[];
    lc_serializable: boolean;
    protected bound: Runnable<RunInput, RunOutput, CallOptions>;
    protected kwargs: Partial<CallOptions>;
    constructor(fields: {
        bound: Runnable<RunInput, RunOutput, CallOptions>;
        kwargs: Partial<CallOptions>;
    });
    bind(kwargs: Partial<CallOptions>): RunnableBinding<RunInput, RunOutput, CallOptions>;
    invoke(input: RunInput, options?: Partial<CallOptions>): Promise<RunOutput>;
    batch(inputs: RunInput[], options?: Partial<CallOptions> | Partial<CallOptions>[], batchOptions?: {
        maxConcurrency?: number;
    }): Promise<RunOutput[]>;
    stream(input: RunInput, options?: Partial<CallOptions> | undefined): Promise<IterableReadableStream<RunOutput>>;
}
export type RouterInput = {
    key: string;
    input: any;
};
export declare class RouterRunnable<RunInput extends RouterInput, RunnableInput, RunOutput> extends Runnable<RunInput, RunOutput> {
    lc_namespace: string[];
    lc_serializable: boolean;
    runnables: Record<string, Runnable<RunnableInput, RunOutput>>;
    constructor(fields: {
        runnables: Record<string, Runnable<RunnableInput, RunOutput>>;
    });
    invoke(input: RunInput, options?: Partial<BaseCallbackConfig>): Promise<RunOutput>;
    batch(inputs: RunInput[], options?: Partial<BaseCallbackConfig> | Partial<BaseCallbackConfig>[], batchOptions?: {
        maxConcurrency?: number;
    }): Promise<RunOutput[]>;
    stream(input: RunInput, options?: Partial<BaseCallbackConfig>): Promise<IterableReadableStream<RunOutput>>;
}
