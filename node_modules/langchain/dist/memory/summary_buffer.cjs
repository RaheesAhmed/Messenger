"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConversationSummaryBufferMemory = void 0;
const base_js_1 = require("./base.cjs");
const summary_js_1 = require("./summary.cjs");
class ConversationSummaryBufferMemory extends summary_js_1.BaseConversationSummaryMemory {
    constructor(fields) {
        super(fields);
        Object.defineProperty(this, "movingSummaryBuffer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ""
        });
        Object.defineProperty(this, "maxTokenLimit", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 2000
        });
        this.maxTokenLimit = fields?.maxTokenLimit ?? this.maxTokenLimit;
    }
    get memoryKeys() {
        return [this.memoryKey];
    }
    async loadMemoryVariables(_) {
        let buffer = await this.chatHistory.getMessages();
        if (this.movingSummaryBuffer) {
            buffer = [
                new this.summaryChatMessageClass(this.movingSummaryBuffer),
                ...buffer,
            ];
        }
        let finalBuffer;
        if (this.returnMessages) {
            finalBuffer = buffer;
        }
        else {
            finalBuffer = (0, base_js_1.getBufferString)(buffer, this.humanPrefix, this.aiPrefix);
        }
        return { [this.memoryKey]: finalBuffer };
    }
    async saveContext(inputValues, outputValues) {
        await super.saveContext(inputValues, outputValues);
        await this.prune();
    }
    async prune() {
        // Prune buffer if it exceeds max token limit
        let buffer = await this.chatHistory.getMessages();
        if (this.movingSummaryBuffer) {
            buffer = [
                new this.summaryChatMessageClass(this.movingSummaryBuffer),
                ...buffer,
            ];
        }
        let currBufferLength = await this.llm.getNumTokens((0, base_js_1.getBufferString)(buffer, this.humanPrefix, this.aiPrefix));
        if (currBufferLength > this.maxTokenLimit) {
            const prunedMemory = [];
            while (currBufferLength > this.maxTokenLimit) {
                const poppedMessage = buffer.shift();
                if (poppedMessage) {
                    prunedMemory.push(poppedMessage);
                    currBufferLength = await this.llm.getNumTokens((0, base_js_1.getBufferString)(buffer, this.humanPrefix, this.aiPrefix));
                }
            }
            this.movingSummaryBuffer = await this.predictNewSummary(prunedMemory, this.movingSummaryBuffer);
        }
    }
    async clear() {
        await super.clear();
        this.movingSummaryBuffer = "";
    }
}
exports.ConversationSummaryBufferMemory = ConversationSummaryBufferMemory;
